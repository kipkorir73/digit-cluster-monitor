<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv Volatility Cluster Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        input {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            width: 200px;
            transition: all 0.3s ease;
        }

        input:focus {
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        select, button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .status {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .status.connected {
            background: rgba(76, 175, 80, 0.3);
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.3);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .volatility-monitors {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .volatility-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .volatility-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .volatility-title {
            font-size: 1.3em;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .last-tick {
            font-size: 1.1em;
            color: #ffd700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .digit-stream {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            min-height: 40px;
            align-items: center;
        }

        .digit {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .digit.cluster-2 {
            background: rgba(255, 193, 7, 0.7);
            color: #000;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .digit.cluster-3 {
            background: rgba(255, 152, 0, 0.8);
            color: #fff;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }

        .digit.cluster-4 {
            background: rgba(244, 67, 54, 0.8);
            color: #fff;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .digit.cluster-5 {
            background: rgba(156, 39, 176, 0.8);
            color: #fff;
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.5);
        }

        .digit.cluster-6 {
            background: rgba(103, 58, 183, 0.9);
            color: #fff;
            box-shadow: 0 0 15px rgba(103, 58, 183, 0.7);
        }

        .pattern-info {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.9em;
        }

        .pattern-badge {
            background: rgba(76, 175, 80, 0.3);
            padding: 4px 8px;
            border-radius: 5px;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .stats-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stats-card h3 {
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9em;
            margin-top: 5px;
        }

        .alerts-log {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }

        .alert-item {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-left: 4px solid #ffd700;
            font-size: 0.9em;
        }

        .alert-time {
            color: #ccc;
            font-size: 0.8em;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .digit-stream {
                justify-content: center;
            }
            
            .digit {
                font-size: 16px;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¯ Deriv Volatility Cluster Monitor</h1>
            <p>Real-time pattern detection across all volatility indices</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="appIdInput">App ID:</label>
                <input type="text" id="appIdInput" placeholder="Enter your Deriv app_id" value="1089" style="padding: 10px 15px; border: none; border-radius: 8px; background: rgba(255, 255, 255, 0.2); color: white; font-size: 16px; width: 200px;">
            </div>
            <div class="control-group">
                <label for="volatilitySelect">Display Volatility:</label>
                <select id="volatilitySelect">
                    <option value="R_10">Volatility 10</option>
                    <option value="R_25" selected>Volatility 25</option>
                    <option value="R_50">Volatility 50</option>
                    <option value="R_75">Volatility 75</option>
                    <option value="R_100">Volatility 100</option>
                </select>
            </div>
            <div class="control-group">
                <label for="alertThreshold">Alert Threshold:</label>
                <select id="alertThreshold">
                    <option value="2">2 Clusters</option>
                    <option value="3">3 Clusters</option>
                    <option value="4" selected>4 Clusters</option>
                    <option value="5">5 Clusters</option>
                    <option value="6">6 Clusters</option>
                </select>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="connectBtn">Connect</button>
            </div>
        </div>

        <div class="status disconnected" id="status">
            Disconnected - Click Connect to start monitoring
        </div>

        <div class="main-content">
            <div class="volatility-monitors" id="volatilityMonitors">
                <!-- Volatility cards will be generated here -->
            </div>

            <div class="sidebar">
                <div class="stats-card">
                    <h3>ðŸ“Š Pattern Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-number" id="clusters2">0</div>
                            <div class="stat-label">Ended at 2</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters3">0</div>
                            <div class="stat-label">Ended at 3</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters4">0</div>
                            <div class="stat-label">Ended at 4</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters5">0</div>
                            <div class="stat-label">Ended at 5</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters6">0</div>
                            <div class="stat-label">Ended at 6</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters7">0</div>
                            <div class="stat-label">7+ Clusters</div>
                        </div>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>ðŸ”” Recent Alerts</h3>
                    <div class="alerts-log" id="alertsLog">
                        <div class="alert-item">
                            <div>System ready - waiting for patterns...</div>
                            <div class="alert-time">Ready to monitor</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class VolatilityMonitor {
            constructor() {
                this.socket = null;
                this.volatilities = ['R_10', 'R_25', 'R_50', 'R_75', 'R_100'];
                this.data = {};
                this.stats = { 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 };
                this.alertThreshold = 4;
                this.isConnected = false;
                this.speechSynthesis = window.speechSynthesis;
                this.reconnectTimer = null;
                this.reconnectInterval = 20000; // 20 seconds
                this.shouldReconnect = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                
                this.initializeData();
                this.initializeUI();
                this.bindEvents();
            }

            initializeData() {
                this.volatilities.forEach(vol => {
                    this.data[vol] = {
                        digits: [],
                        patterns: {}, // Track patterns for each digit
                        clusterVisualization: [],
                        lastTick: null
                    };
                    
                    // Initialize pattern tracking for each digit (0-9)
                    for (let digit = 0; digit <= 9; digit++) {
                        this.data[vol].patterns[digit] = {
                            clusters: [],
                            activeClusters: 0,
                            completed: false,
                            maxClusters: 0
                        };
                    }
                });
            }

            initializeUI() {
                const monitorsContainer = document.getElementById('volatilityMonitors');
                
                this.volatilities.forEach(vol => {
                    const card = document.createElement('div');
                    card.className = 'volatility-card';
                    card.innerHTML = `
                        <div class="volatility-header">
                            <div class="volatility-title">${vol.replace('_', ' ')}</div>
                            <div class="last-tick" id="lastTick-${vol}">--</div>
                        </div>
                        <div class="digit-stream" id="stream-${vol}"></div>
                        <div class="pattern-info" id="patterns-${vol}"></div>
                    `;
                    monitorsContainer.appendChild(card);
                });
            }

            bindEvents() {
                document.getElementById('connectBtn').addEventListener('click', () => {
                    if (this.isConnected) {
                        this.disconnect();
                    } else {
                        this.connect();
                    }
                });

                document.getElementById('alertThreshold').addEventListener('change', (e) => {
                    this.alertThreshold = parseInt(e.target.value);
                });
            }

            connect() {
                const appId = document.getElementById('appIdInput').value.trim();
                if (!appId) {
                    this.updateStatus('Please enter a valid App ID', 'disconnected');
                    return;
                }

                // Clear any existing reconnect timer
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }

                this.shouldReconnect = true;
                this.updateStatus('Connecting...', 'disconnected');

                this.socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);

                this.socket.onopen = () => {
                    console.log('Connected to Deriv WebSocket');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.updateStatus('Connected - Subscribing to volatilities...', 'connected');
                    document.getElementById('connectBtn').textContent = 'Disconnect';
                    
                    // Subscribe to all volatilities
                    this.volatilities.forEach((vol, index) => {
                        setTimeout(() => {
                            const subscribeMessage = {
                                ticks: vol,
                                subscribe: 1,
                                req_id: index + 1
                            };
                            console.log(`Subscribing to ${vol}:`, subscribeMessage);
                            this.socket.send(JSON.stringify(subscribeMessage));
                        }, index * 200);
                    });
                };

                this.socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('Received data:', data);
                        
                        if (data.tick) {
                            this.processTick(data.tick);
                        } else if (data.subscription) {
                            console.log('Subscription confirmed:', data.subscription);
                            this.updateStatus('Connected - Monitoring all volatilities', 'connected');
                        } else if (data.error) {
                            console.error('API Error:', data.error);
                            this.updateStatus(`Error: ${data.error.message}`, 'disconnected');
                        }
                    } catch (e) {
                        console.error('Error parsing message:', e, 'Raw data:', event.data);
                    }
                };

                this.socket.onclose = (event) => {
                    console.log('Disconnected from Deriv WebSocket', event);
                    this.isConnected = false;
                    
                    if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
                        this.reconnectAttempts++;
                        this.updateStatus(`Disconnected - Reconnecting in 20s... (Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'disconnected');
                        
                        this.reconnectTimer = setTimeout(() => {
                            console.log(`Reconnection attempt ${this.reconnectAttempts}`);
                            this.connect();
                        }, this.reconnectInterval);
                    } else {
                        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                            this.updateStatus('Max reconnection attempts reached - Click Connect to retry', 'disconnected');
                        } else {
                            this.updateStatus('Disconnected - Click Connect to start monitoring', 'disconnected');
                        }
                        document.getElementById('connectBtn').textContent = 'Connect';
                        this.shouldReconnect = false;
                    }
                };

                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateStatus('Connection error - Will retry automatically', 'disconnected');
                };
            }

            disconnect() {
                this.shouldReconnect = false;
                if (this.socket) {
                    this.socket.close();
                }
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }
                this.isConnected = false;
                this.updateStatus('Disconnected - Click Connect to start monitoring', 'disconnected');
                document.getElementById('connectBtn').textContent = 'Connect';
            }

            updateStatus(message, className) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${className}`;
            }

            processTick(tick) {
                const symbol = tick.symbol;
                let quote = tick.quote;
                
                if (!this.data[symbol]) {
                    console.log(`Unknown symbol: ${symbol}`);
                    return;
                }

                if (!quote) {
                    console.log('No quote in tick data:', tick);
                    return;
                }

                // Extract last digit
                const quoteStr = quote.toString();
                const lastDigit = parseInt(quoteStr.slice(-1));
                
                console.log(`${symbol}: ${quote} -> digit ${lastDigit}`);
                
                // Update last tick display
                const lastTickEl = document.getElementById(`lastTick-${symbol}`);
                if (lastTickEl) {
                    lastTickEl.textContent = typeof quote === 'number' ? quote.toFixed(5) : quote;
                }
                
                // Add digit to stream
                this.data[symbol].digits.push(lastDigit);
                
                // Keep only last 100 digits for better pattern detection
                if (this.data[symbol].digits.length > 100) {
                    this.data[symbol].digits.shift();
                }
                
                // Analyze patterns
                this.analyzePatterns(symbol);
                
                // Update UI
                this.updateDigitStream(symbol);
                this.updatePatternInfo(symbol);
            }

            analyzePatterns(symbol) {
                const digits = this.data[symbol].digits;
                
                // Reset patterns for fresh analysis
                for (let digit = 0; digit <= 9; digit++) {
                    this.data[symbol].patterns[digit] = {
                        clusters: [],
                        activeClusters: 0,
                        completed: false,
                        maxClusters: 0
                    };
                }
                
                // Find all clusters for each digit
                for (let digit = 0; digit <= 9; digit++) {
                    this.findClustersForDigit(symbol, digit, digits);
                }
                
                // Update cluster visualization
                this.updateClusterVisualization(symbol);
            }

            findClustersForDigit(symbol, digit, digits) {
                const clusters = [];
                let i = 0;
                
                while (i < digits.length) {
                    if (digits[i] === digit) {
                        // Found start of potential cluster
                        let clusterStart = i;
                        let clusterEnd = i;
                        
                        // Find end of cluster
                        while (clusterEnd + 1 < digits.length && digits[clusterEnd + 1] === digit) {
                            clusterEnd++;
                        }
                        
                        // Only consider clusters of 2 or more
                        if (clusterEnd - clusterStart + 1 >= 2) {
                            clusters.push({
                                start: clusterStart,
                                end: clusterEnd,
                                size: clusterEnd - clusterStart + 1
                            });
                        }
                        
                        i = clusterEnd + 1;
                    } else {
                        i++;
                    }
                }
                
                // Analyze cluster patterns
                this.analyzeClusterPatterns(symbol, digit, clusters);
            }

            analyzeClusterPatterns(symbol, digit, clusters) {
                if (clusters.length === 0) return;
                
                // Check for valid patterns (clusters separated by single digits only)
                const validPatterns = [];
                let currentPattern = [clusters[0]];
                
                for (let i = 1; i < clusters.length; i++) {
                    const prevCluster = clusters[i - 1];
                    const currentCluster = clusters[i];
                    
                    // Check if there's only single digits between clusters
                    const gapStart = prevCluster.end + 1;
                    const gapEnd = currentCluster.start - 1;
                    
                    let validGap = true;
                    for (let j = gapStart; j <= gapEnd; j++) {
                        if (this.data[symbol].digits[j] === digit) {
                            validGap = false;
                            break;
                        }
                    }
                    
                    if (validGap) {
                        // Continue current pattern
                        currentPattern.push(currentCluster);
                    } else {
                        // End current pattern and start new one
                        if (currentPattern.length >= 2) {
                            validPatterns.push([...currentPattern]);
                        }
                        currentPattern = [currentCluster];
                    }
                }
                
                // Add the last pattern if valid
                if (currentPattern.length >= 2) {
                    validPatterns.push([...currentPattern]);
                }
                
                // Update pattern data
                if (validPatterns.length > 0) {
                    const longestPattern = validPatterns.reduce((longest, current) => 
                        current.length > longest.length ? current : longest
                    );
                    
                    this.data[symbol].patterns[digit].clusters = longestPattern;
                    this.data[symbol].patterns[digit].activeClusters = longestPattern.length;
                    this.data[symbol].patterns[digit].maxClusters = longestPattern.length;
                    
                    // Check if pattern is completed (last cluster is not at the end)
                    const lastCluster = longestPattern[longestPattern.length - 1];
                    this.data[symbol].patterns[digit].completed = lastCluster.end < this.data[symbol].digits.length - 1;
                    
                    // Record completed patterns
                    if (this.data[symbol].patterns[digit].completed) {
                        this.recordPatternEnd(longestPattern.length);
                    }
                    
                    // Check for alerts
                    if (longestPattern.length >= this.alertThreshold) {
                        this.triggerAlert(symbol, digit, longestPattern.length);
                    }
                }
            }

            updateClusterVisualization(symbol) {
                const digits = this.data[symbol].digits;
                const visualization = [];
                
                for (let i = 0; i < digits.length; i++) {
                    const digit = digits[i];
                    const clusterSize = this.getClusterSizeAtPosition(symbol, i);
                    visualization.push({
                        digit: digit,
                        clusterSize: clusterSize
                    });
                }
                
                this.data[symbol].clusterVisualization = visualization;
            }

            getClusterSizeAtPosition(symbol, position) {
                const digits = this.data[symbol].digits;
                const digit = digits[position];
                
                // Check all patterns for this digit
                for (let d = 0; d <= 9; d++) {
                    const patterns = this.data[symbol].patterns[d];
                    if (patterns.clusters.length > 0) {
                        for (const cluster of patterns.clusters) {
                            if (position >= cluster.start && position <= cluster.end && d === digit) {
                                return cluster.size;
                            }
                        }
                    }
                }
                
                return 0;
            }

            recordPatternEnd(clusterCount) {
                const maxStat = Math.min(clusterCount, 7);
                const statKey = maxStat === 7 ? 7 : clusterCount;
                
                this.stats[statKey]++;
                
                // Update UI
                if (statKey === 7) {
                    document.getElementById('clusters7').textContent = this.stats[7];
                } else {
                    document.getElementById(`clusters${statKey}`).textContent = this.stats[statKey];
                }
            }

            triggerAlert(symbol, digit, clusterCount) {
                const message = `Digit ${digit} has formed ${clusterCount} clusters on ${symbol.replace('_', ' ')}`;
                
                // Voice alert
                if (this.speechSynthesis) {
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.rate = 0.8;
                    utterance.pitch = 1.1;
                    this.speechSynthesis.speak(utterance);
                }
                
                // Add to alerts log
                this.addAlert(message);
                
                console.log('ALERT:', message);
            }

            addAlert(message) {
                const alertsLog = document.getElementById('alertsLog');
                const alertItem = document.createElement('div');
                alertItem.className = 'alert-item';
                alertItem.innerHTML = `
                    <div>${message}</div>
                    <div class="alert-time">${new Date().toLocaleTimeString()}</div>
                `;
                
                alertsLog.insertBefore(alertItem, alertsLog.firstChild);
                
                // Keep only last 10 alerts
                while (alertsLog.children.length > 10) {
                    alertsLog.removeChild(alertsLog.lastChild);
                }
            }

            updateDigitStream(symbol) {
                const streamEl = document.getElementById(`stream-${symbol}`);
                const visualization = this.data[symbol].clusterVisualization;
                
                streamEl.innerHTML = '';
                
                // Create digit elements with cluster highlighting
                visualization.forEach((item, index) => {
                    const digitEl = document.createElement('div');
                    digitEl.className = 'digit';
                    digitEl.textContent = item.digit;
                    
                    if (item.clusterSize >= 2) {
                        digitEl.classList.add(`cluster-${Math.min(item.clusterSize, 6)}`);
                    }
                    
                    streamEl.appendChild(digitEl);
                });
            }

            updatePatternInfo(symbol) {
                const patternEl = document.getElementById(`patterns-${symbol}`);
                const patterns = this.data[symbol].patterns;
                
                patternEl.innerHTML = '';
                
                for (let
