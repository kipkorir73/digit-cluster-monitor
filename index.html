<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Real-time volatility cluster monitor for Deriv platform">
    <title>Deriv Volatility Cluster Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        input, select, button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus, button:focus {
            background: rgba(255, 255, 255, 0.3);
            outline: 2px solid #ffd700;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .status.connected {
            background: rgba(76, 175, 80, 0.3);
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.3);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .volatility-monitors {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .volatility-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .volatility-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .volatility-title {
            font-size: 1.3em;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .last-tick {
            font-size: 1.1em;
            color: #ffd700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .digit-stream {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            min-height: 40px;
            align-items: center;
        }

        .digit {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .digit.cluster-2 {
            background: rgba(255, 193, 7, 0.7);
            color: #000;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .digit.cluster-3 {
            background: rgba(255, 152, 0, 0.8);
            color: #fff;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }

        .digit.cluster-4 {
            background: rgba(244, 67, 54, 0.8);
            color: #fff;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .digit.cluster-5 {
            background: rgba(156, 39, 176, 0.8);
            color: #fff;
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.5);
        }

        .digit.cluster-6 {
            background: rgba(103, 58, 183, 0.9);
            color: #fff;
            box-shadow: 0 0 15px rgba(103, 58, 183, 0.7);
        }

        .pattern-info {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.9em;
        }

        .pattern-badge {
            background: rgba(76, 175, 80, 0.3);
            padding: 4px 8px;
            border-radius: 5px;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .stats-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stats-card h3 {
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9em;
            margin-top: 5px;
        }

        .alerts-log {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }

        .alert-item {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-left: 4px solid #ffd700;
            font-size: 0.9em;
        }

        .alert-time {
            color: #ccc;
            font-size: 0.8em;
        }

        .toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .toast.show {
            opacity: 1;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .digit-stream {
                justify-content: center;
            }
            
            .digit {
                font-size: 16px;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¯ Deriv Volatility Cluster Monitor</h1>
            <p>Real-time pattern detection across all volatility indices</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="appIdInput">App ID:</label>
                <input type="text" id="appIdInput" placeholder="Enter your Deriv app_id" value="1089" aria-describedby="appIdHelp">
                <small id="appIdHelp" class="sr-only">Enter your Deriv API application ID</small>
            </div>
            <div class="control-group">
                <label for="volatilitySelect">Display Volatility:</label>
                <select id="volatilitySelect" aria-label="Select volatility index">
                    <option value="R_10">Volatility 10</option>
                    <option value="R_25" selected>Volatility 25</option>
                    <option value="R_50">Volatility 50</option>
                    <option value="R_75">Volatility 75</option>
                    <option value="R_100">Volatility 100</option>
                </select>
            </div>
            <div class="control-group">
                <label for="alertThreshold">Alert Threshold:</label>
                <select id="alertThreshold" aria-label="Select alert threshold">
                    <option value="2">2 Clusters</option>
                    <option value="3">3 Clusters</option>
                    <option value="4" selected>4 Clusters</option>
                    <option value="5">5 Clusters</option>
                    <option value="6">6 Clusters</option>
                </select>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="connectBtn" aria-label="Connect or disconnect from WebSocket">Connect</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="resetStatsBtn" aria-label="Reset pattern statistics">Reset Stats</button>
            </div>
        </div>

        <div class="status disconnected" id="status" role="status">
            Disconnected - Click Connect to start monitoring
        </div>

        <div class="main-content">
            <div class="volatility-monitors" id="volatilityMonitors"></div>

            <div class="sidebar">
                <div class="stats-card">
                    <h3>ðŸ“Š Pattern Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-number" id="clusters2">0</div>
                            <div class="stat-label">Ended at 2</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters3">0</div>
                            <div class="stat-label">Ended at 3</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters4">0</div>
                            <div class="stat-label">Ended at 4</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters5">0</div>
                            <div class="stat-label">Ended at 5</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="clusters6">0</div>
                            <div class="stat-label">Ended at 6</div>
                        </div>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>ðŸ”” Recent Alerts</h3>
                    <div class="alerts-log" id="alertsLog" aria-live="polite">
                        <div class="alert-item">
                            <div>System ready - waiting for pats</div>
                            <div class="alert-time">Ready to monitor</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="toast-container" id="toastContainer" aria-live="polite"></div>

    <script>
        class VolatilityMonitor {
            constructor() {
                this.socket = null;
                this.volatilities = ['R_10', 'R_25', 'R_50', 'R_75', 'R_100'];
                this.data = {};
                this.stats = { 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
                this.alertThreshold = 4;
                this.isConnected = false;
                this.speechSynthesis = window.speechSynthesis;
                this.reconnectTimeout = null;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectMultiplier = 1.5;
                this.isFirstConnection = true;
                this.debounceTimeout = null;

                this.initializeData();
                this.initializeUI();
                this.bindEvents();
                this.loadSettings();
            }

            initializeData() {
                this.volatilities.forEach(vol => {
                    this.data[vol] = {
                        digits: [],
                        patternTracking: {},
                        clusterVisualization: [],
                        lastTick: null
                    };
                    
                    for (let digit = 0; digit <= 9; digit++) {
                        this.data[vol].patternTracking[digit] = {
                            currentClusters: 0,
                            isActive: false,
                            lastClusterEnd: -1,
                            expectedNextCluster: false
                        };
                    }
                });
            }

            initializeUI() {
                const monitorsContainer = document.getElementById('volatilityMonitors');
                
                this.volatilities.forEach(vol => {
                    const card = document.createElement('div');
                    card.className = 'volatility-card';
                    card.setAttribute('aria-label', `Volatility monitor for ${vol.replace('_', ' ')}`);
                    card.innerHTML = `
                        <div class="volatility-header">
                            <div class="volatility-title">${vol.replace('_', ' ')}</div>
                            <div class="last-tick" id="lastTick-${vol}" aria-live="polite">--</div>
                        </div>
                        <div class="digit-stream" id="stream-${vol}" aria-label="Digit stream for ${vol.replace('_', ' ')}"></div>
                        <div class="pattern-info" id="patterns-${vol}" aria-label="Pattern information for ${vol.replace('_', ' ')}"></div>
                    `;
                    monitorsContainer.appendChild(card);
                });
            }

            bindEvents() {
                const connectBtn = document.getElementById('connectBtn');
                connectBtn.addEventListener('click', () => {
                    if (this.isConnected) {
                        this.disconnect();
                    } else {
                        this.connect();
                    }
                });

                document.getElementById('alertThreshold').addEventListener('change', (e) => {
                    this.alertThreshold = parseInt(e.target.value);
                    this.saveSettings();
                });

                document.getElementById('appIdInput').addEventListener('change', () => {
                    this.saveSettings();
                });

                document.getElementById('resetStatsBtn').addEventListener('click', () => {
                    this.resetStats();
                });

                // Debounced window resize handler
                window.addEventListener('resize', () => {
                    clearTimeout(this.debounceTimeout);
                    this.debounceTimeout = setTimeout(() => this.updateDigitStreamAll(), 100);
                });
            }

            loadSettings() {
                try {
                    const settings = JSON.parse(localStorage.getItem('volatilityMonitorSettings') || '{}');
                    if (settings.appId) {
                        document.getElementById('appIdInput').value = settings.appId;
                    }
                    if (settings.alertThreshold) {
                        document.getElementById('alertThreshold').value = settings.alertThreshold;
                        this.alertThreshold = parseInt(settings.alertThreshold);
                    }
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }

            saveSettings() {
                try {
                    const settings = {
                        appId: document.getElementById('appIdInput').value.trim(),
                        alertThreshold: document.getElementById('alertThreshold').value
                    };
                    localStorage.setItem('volatilityMonitorSettings', JSON.stringify(settings));
                } catch (e) {
                    console.error('Error saving settings:', e);
                }
            }

            resetStats() {
                Object.keys(this.stats).forEach(key => {
                    this.stats[key] = 0;
                    const element = document.getElementById(`clusters${key}`);
                    if (element) element.textContent = '0';
                });
                this.showToast('Statistics reset');
                this.addAlert('Pattern statistics reset');
            }

            connect(isReconnect = false) {
                const appId = document.getElementById('appIdInput').value.trim();
                if (!appId || !/^\d+$/.test(appId)) {
                    this.updateStatus('Please enter a valid numeric App ID', 'disconnected');
                    this.showToast('Invalid App ID');
                    return;
                }

                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }

                if (isReconnect && !this.isFirstConnection) {
                    this.clearLiveDigitData();
                    this.showToast('Reconnected to WebSocket');
                    this.addAlert('Reconnected to WebSocket');
                }

                if (!isReconnect) {
                    this.isFirstConnection = true;
                }

                try {
                    this.socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
                } catch (e) {
                    console.error('WebSocket creation error:', e);
                    this.updateStatus('Failed to create WebSocket connection', 'disconnected');
                    return;
                }

                this.socket.onopen = () => {
                    console.log('Connected to Deriv WebSocket');
                    this.isConnected = true;
                    this.updateStatus('Connected - Subscribing to volatilities...', 'connected');
                    document.getElementById('connectBtn').textContent = 'Disconnect';
                    document.getElementById('connectBtn').setAttribute('aria-label', 'Disconnect from WebSocket');
                    this.reconnectDelay = 1000;
                    this.isFirstConnection = false;

                    this.volatilities.forEach((vol, index) => {
                        setTimeout(() => {
                            const subscribeMessage = {
                                ticks: vol,
                                subscribe: 1,
                                req_id: index + 1
                            };
                            try {
                                this.socket.send(JSON.stringify(subscribeMessage));
                            } catch (e) {
                                console.error(`Error subscribing to ${vol}:`, e);
                            }
                        }, index * 200);
                    });
                };

                this.socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.tick) {
                            this.processTick(data.tick);
                        } else if (data.subscription) {
                            this.updateStatus('Connected - Monitoring all volatilities', 'connected');
                        } else if (data.error) {
                            console.error('API Error:', data.error);
                            this.updateStatus(`Error: ${data.error.message}`, 'disconnected');
                            this.showToast(`API Error: ${data.error.message}`);
                        }
                    } catch (e) {
                        console.error('Error parsing message:', e);
                        this.showToast('Error processing data');
                    }
                };

                this.socket.onclose = () => {
                    console.log('WebSocket connection closed.');
                    this.isConnected = false;
                    this.updateStatus('Disconnected - Attempting to reconnect...', 'disconnected');
                    document.getElementById('connectBtn').textContent = 'Connect';
                    document.getElementById('connectBtn').setAttribute('aria-label', 'Connect to WebSocket');

                    if (this.reconnectTimeout === null) {
                        this.scheduleReconnect();
                    }
                };

                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateStatus('Connection error - Check console for details', 'disconnected');
                    this.showToast('WebSocket connection error');
                };
            }

            scheduleReconnect() {
                this.reconnectTimeout = setTimeout(() => {
                    console.log(`Attempting to reconnect in ${this.reconnectDelay / 1000} seconds...`);
                    this.connect(true);
                    this.reconnectDelay = Math.min(this.reconnectDelay * this.reconnectMultiplier, this.maxReconnectDelay);
                }, this.reconnectDelay);
            }

            disconnect() {
                if (this.socket) {
                    if (this.reconnectTimeout) {
                        clearTimeout(this.reconnectTimeout);
                        this.reconnectTimeout = null;
                    }
                    try {
                        this.socket.close();
                    } catch (e) {
                        console.error('Error closing WebSocket:', e);
                    }
                    this.socket = null;
                    this.isConnected = false;
                    this.updateStatus('Disconnected - Click Connect to start monitoring', 'disconnected');
                    document.getElementById('connectBtn').textContent = 'Connect';
                    document.getElementById('connectBtn').setAttribute('aria-label', 'Connect to WebSocket');
                    this.isFirstConnection = true;
                    this.showToast('Disconnected from WebSocket');
                    this.addAlert('Disconnected from WebSocket');
                }
            }

            clearLiveDigitData() {
                this.volatilities.forEach(vol => {
                    this.data[vol].digits = [];
                    this.data[vol].clusterVisualization = [];
                    this.data[vol].lastTick = null;
                    for (let digit = 0; digit <= 9; digit++) {
                        this.data[vol].patternTracking[digit] = {
                            currentClusters: 0,
                            isActive: false,
                            lastClusterEnd: -1,
                            expectedNextCluster: false
                        };
                    }
                    this.updateDigitStream(vol);
                    this.updatePatternInfo(vol);
                    document.getElementById(`lastTick-${vol}`).textContent = '--';
                });
            }

            showToast(message, duration = 3000) {
                const toastContainer = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                toast.setAttribute('role', 'alert');
                toastContainer.appendChild(toast);

                void toast.offsetWidth;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => {
                        toast.remove();
                    }, { once: true });
                }, duration);
            }

            updateStatus(message, className) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${className}`;
            }

            processTick(tick) {
                const symbol = tick.symbol;
                let quote = tick.quote;
                
                if (!this.data[symbol] || quote == null) {
                    return;
                }

                const quoteStr = quote.toString();
                const lastDigit = parseInt(quoteStr.slice(-1));
                
                if (isNaN(lastDigit)) {
                    console.warn(`Invalid digit for ${symbol}: quote=${quote}`);
                    return;
                }

                const lastTickEl = document.getElementById(`lastTick-${symbol}`);
                if (lastTickEl) {
                    lastTickEl.textContent = typeof quote === 'number' ? quote.toFixed(5) : quote;
                }
                
                this.data[symbol].digits.push(lastDigit);
                
                if (this.data[symbol].digits.length > 40) {
                    this.data[symbol].digits.shift();
                    for (let digit = 0; digit <= 9; digit++) {
                        if (this.data[symbol].patternTracking[digit].lastClusterEnd > 0) {
                            this.data[symbol].patternTracking[digit].lastClusterEnd--;
                        }
                    }
                }
                
                this.analyzePatterns(symbol);
                this.updateDigitStream(symbol);
                this.updatePatternInfo(symbol);
            }

            analyzePatterns(symbol) {
                const digits = this.data[symbol].digits;
                
                if (digits.length < 2) return;
                
                const clusters = this.findAllClusters(digits);
                
                for (let digit = 0; digit <= 9; digit++) {
                    this.updatePatternForDigitFixed(symbol, digit, clusters);
                }
                
                this.updateClusterVisualization(symbol);
            }

            findAllClusters(digits) {
                const clusters = [];
                
                for (let digit = 0; digit <= 9; digit++) {
                    const digitClusters = [];
                    let i = 0;
                    
                    while (i < digits.length) {
                        if (digits[i] === digit) {
                            let start = i;
                            let end = i;
                            
                            while (end + 1 < digits.length && digits[end + 1] === digit) {
                                end++;
                            }
                            
                            if (end - start + 1 >= 2) {
                                digitClusters.push({
                                    start: start,
                                    end: end,
                                    size: end - start + 1,
                                    digit: digit
                                });
                            }
                            
                            i = end + 1;
                        } else {
                            i++;
                        }
                    }
                    
                    if (digitClusters.length > 0) {
                        clusters.push({
                            digit: digit,
                            clusters: digitClusters
                        });
                    }
                }
                
                return clusters;
            }

            updatePatternForDigitFixed(symbol, digit, allClusters) {
                const tracking = this.data[symbol].patternTracking[digit];
                const digits = this.data[symbol].digits;
                const digitData = allClusters.find(d => d.digit === digit);
                const clusters = digitData ? digitData.clusters : [];
                
                if (clusters.length === 0) {
                    if (tracking.isActive) {
                        const lastDigitIndex = digits.length - 1;
                        if (digits[lastDigitIndex] === digit) {
                            if (tracking.currentClusters >= 2) {
                                this.recordPatternEnd(tracking.currentClusters);
                            }
                            tracking.isActive = false;
                            tracking.currentClusters = 0;
                            tracking.lastClusterEnd = -1;
                        }
                    }
                    return;
                }
                
                const latestCluster = clusters[clusters.length - 1];
                
                if (!tracking.isActive) {
                    tracking.isActive = true;
                    tracking.currentClusters = clusters.length;
                    tracking.lastClusterEnd = latestCluster.end;
                } else {
                    const newClusterCount = clusters.length;
                    
                    if (newClusterCount > tracking.currentClusters) {
                        const previousCluster = clusters[newClusterCount - 2];
                        
                        if (this.hasSoloDigitBetweenClusters(digits, previousCluster.end, latestCluster.start, digit)) {
                            if (tracking.currentClusters >= 2) {
                                this.recordPatternEnd(tracking.currentClusters);
                            }
                            tracking.currentClusters = 1;
                        } else {
                            tracking.currentClusters = newClusterCount;
                        }
                        
                        tracking.lastClusterEnd = latestCluster.end;
                        
                        if (tracking.currentClusters === this.alertThreshold) {
                            this.triggerAlert(symbol, digit, tracking.currentClusters);
                        }
                    }
                }
            }

            hasSoloDigitBetweenClusters(digits, clusterEnd, nextClusterStart, digit) {
                for (let i = clusterEnd + 1; i < nextClusterStart; i++) {
                    if (digits[i] === digit) {
                        return true;
                    }
                }
                return false;
            }

            recordPatternEnd(clusterCount) {
                if (clusterCount >= 2 && clusterCount <= 6) {
                    this.stats[clusterCount]++;
                    const element = document.getElementById(`clusters${clusterCount}`);
                    if (element) {
                        element.textContent = this.stats[clusterCount];
                    }
                }
            }

            triggerAlert(symbol, digit, clusterCount) {
                const message = `ðŸš¨ Digit ${digit} reached ${clusterCount} clusters on ${symbol.replace('_', ' ')}`;
                
                if (this.speechSynthesis) {
                    try {
                        const utterance = new SpeechSynthesisUtterance(message);
                        utterance.rate = 0.8;
                        utterance.pitch = 1.1;
                        this.speechSynthesis.speak(utterance);
                    } catch (e) {
                        console.error('Speech synthesis error:', e);
                    }
                }
                
                this.addAlert(message);
                this.showToast(message);
            }

            addAlert(message) {
                const alertsLog = document.getElementById('alertsLog');
                const alertItem = document.createElement('div');
                alertItem.className = 'alert-item';
                alertItem.innerHTML = `
                    <div>${message}</div>
                    <div class="alert-time">${new Date().toLocaleTimeString()}</div>
                `;
                
                alertsLog.insertBefore(alertItem, alertsLog.firstChild);
                
                while (alertsLog.children.length > 10) {
                    alertsLog.removeChild(alertsLog.lastChild);
                }
            }

            updateClusterVisualization(symbol) {
                const digits = this.data[symbol].digits;
                const visualization = [];
                
                for (let i = 0; i < digits.length; i++) {
                    const digit = digits[i];
                    const clusterSize = this.getClusterSizeAtPosition(digits, i, digit);
                    visualization.push({
                        digit: digit,
                        clusterSize: clusterSize
                    });
                }
                
                this.data[symbol].clusterVisualization = visualization;
            }

            getClusterSizeAtPosition(digits, position, digit) {
                if (digits[position] !== digit) return 0;
                
                let start = position;
                let end = position;
                
                while (start > 0 && digits[start - 1] === digit) {
                    start--;
                }
                
                while (end < digits.length - 1 && digits[end + 1] === digit) {
                    end++;
                }
                
                const clusterSize = end - start + 1;
                return clusterSize >= 2 ? clusterSize : 0;
            }

            updateDigitStream(symbol) {
                const streamEl = document.getElementById(`stream-${symbol}`);
                const visualization = this.data[symbol].clusterVisualization;

                streamEl.innerHTML = '';

                visualization.forEach((item, index) => {
                    const digitEl = document.createElement('div');
                    digitEl.className = 'digit';
                    digitEl.textContent = String(item.digit);
                    digitEl.setAttribute('aria-label', `Digit ${item.digit}${item.clusterSize >= 2 ? ` in cluster of ${item.clusterSize}` : ''}`);

                    if (item.clusterSize !== 0 && item.clusterSize >= 2) {
                        digitEl.classList.add(`cluster-${Math.min(item.clusterSize, 6)}`);
                    }

                    streamEl.appendChild(digitEl);
                });
            }

            updateDigitStreamAll() {
                this.volatilities.forEach(vol => this.updateDigitStream(vol));
            }

            updatePatternInfo(symbol) {
                const patternEl = document.getElementById(`patterns-${symbol}`);
                const tracking = this.data[symbol].patternTracking;
                
                patternEl.innerHTML = '';
                
                for (let digit = 0; digit <= 9; digit++) {
                    const count = tracking[digit].currentClusters;
                    if (count >= 1 && tracking[digit].among0].isActive) {
                        const badge = document.createElement('div');
                        badge.className = 'pattern-badge';
                        badge.textContent = `${digit}: ${count} clusters`;
                        badge.setAttribute('aria-label', `Digit ${digit} has ${count} clusters`);
                        patternEl.appendChild(badge);
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new VolatilityMonitor();
        });
    </script>
</body>
</html>
